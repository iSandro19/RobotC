#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Ambient)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#### RobotC File ####//
// Robotica Q8 2022/2023
// Title: Practice 1
// Authors:
//   - Oscar Alejandro Manteiga Seoane
//   - Antonio Vila Lei

// Definitions ################################################################
const int MAX_DISTANCE = 30;
const int FOLLOW_DISTANCE = 30;

const int DEFAULT_SPEED = 50;

const int TURNING_ANGLE = 110;
const int CORNING_ANGLE = 90;

const int LIGHT_FOUND = 40;
const int LIGHT_DETECTED = 20;

// Sephores// Semaphores #################################################################
TSemaphore sem12, sem23, sem34;

// Tasks ######################################################################
/*
 * Escape task
 * This task is in charge of escaping from crashes.
 */
task escape() {
	while(true) {
		int currentDistance = getUSDistance(sonarSensor);

		if(getTouchValue(touchSensor) == 1 || currentDistance < 15) {
			semaphoreLock(sem12);
			if(bDoesTaskOwnSemaphore(sem12)) {
				setMotorSpeed(leftMotor, -DEFAULT_SPEED);
				setMotorSpeed(rightMotor, -DEFAULT_SPEED);

				resetGyro(gyroSensor);
				repeatUntil(getGyroDegrees(gyroSensor) < -CORNING_ANGLE) {
					setMotorSpeed(leftMotor, -DEFAULT_SPEED);
					setMotorSpeed(rightMotor, DEFAULT_SPEED);
				}
				resetGyro(gyroSensor);

				semaphoreUnlock(sem12);
			}
		}
	}
}

/*
 * Light task
 * This task is in charge of detecting the light.
 */
task light(){
	int luz;

	while(true){
		luz = getColorAmbient(colorSensor);

		/*
		if(luz != 0)
			writeDebugStreamLine("Luz = %d", luz);
		*/

		semaphoreLock(sem12);
		if (bDoesTaskOwnSemaphore(sem12)) {

			if(bDoesTaskOwnSemaphore(sem23)) {
				semaphoreUnlock(sem23);
			}
			/*
			if(luz >= LIGHT_DETECTED){
				semaphoreLock(sem23);

				while(luz >= LIGHT_DETECTED) {
					luz = getColorAmbient(colorSensor);

				  setMotorSpeed(leftMotor, 0);
				  setMotorSpeed(rightMotor, 30);
			  }

				while(luz < LIGHT_DETECTED) {
					luz = getColorAmbient(colorSensor);

					setMotorSpeed(leftMotor, 0);
				  setMotorSpeed(rightMotor, 30);
				}
				semaphoreUnlock(sem23);
			}
			*/

			if(luz >= LIGHT_FOUND) {
				writeDebugStreamLine("FOUND");
			  stopAllTasks();
			}

			semaphoreUnlock(sem12);

		} else {
			if(!bDoesTaskOwnSemaphore(sem23)) {
				semaphoreLock(sem23);
			}
		}
	}
}

/*
 * Follow wall task
 * This task is in charge of following the (right) wall.
 */
task follow_wall(){
	bool right_wall = false;

	while(true){
		int currentDistance = getUSDistance(sonarSensor);

		semaphoreLock(sem23);
		if(bDoesTaskOwnSemaphore(sem23)) {

			if(bDoesTaskOwnSemaphore(sem34)) {
				semaphoreUnlock(sem34);
			}

			if(currentDistance < FOLLOW_DISTANCE) {
				semaphoreLock(sem34);
					right_wall = true;
					resetGyro(gyroSensor);
					repeatUntil(getGyroDegrees(gyroSensor) <= -TURNING_ANGLE) {
						setMotorSpeed(leftMotor, -DEFAULT_SPEED);
						setMotorSpeed(rightMotor, DEFAULT_SPEED);
					}
					resetGyro(gyroSensor);
				semaphoreUnlock(sem34);
			}

			if(right_wall && currentDistance > FOLLOW_DISTANCE) {
				semaphoreLock(sem34);
					resetGyro(gyroSensor);
					repeatUntil(getGyroDegrees(gyroSensor) >= 5) {
						setMotorSpeed(leftMotor, DEFAULT_SPEED + 20);
						setMotorSpeed(rightMotor, DEFAULT_SPEED - 20);
					}
					resetGyro(gyroSensor);
				semaphoreUnlock(sem34);
			}
			semaphoreUnlock(sem23);
		}	else {
			if(!bDoesTaskOwnSemaphore(sem34)) {
				semaphoreLock(sem34);
			}
		}
	}
}

/*
 * Go to wall task
 * This task is in charge of going to the (front) wall.
 */
task go_to_wall() {
	while(true) {
		int currentDistance = getUSDistance(sonarSensor);

		semaphoreLock(sem34);
		if(bDoesTaskOwnSemaphore(sem34)) {
			if (currentDistance > MAX_DISTANCE) {
				setMotorSpeed(leftMotor, DEFAULT_SPEED);
				setMotorSpeed(rightMotor, DEFAULT_SPEED);
			}	else {
				setMotorSpeed(leftMotor, currentDistance + 20);
				setMotorSpeed(rightMotor, currentDistance + 20);
			}
			semaphoreUnlock(sem34);
		}
	}
}

// Main #######################################################################
task main() {
	clearDebugStream();
	int luz;

	sleep(1000);

	luz = getColorAmbient(colorSensor);

	semaphoreInitialize(sem12);
	semaphoreInitialize(sem23);
	semaphoreInitialize(sem34);

	startTask(escape);
	startTask(light);
	startTask(follow_wall);
	startTask(go_to_wall);

	while(true){
		luz = getColorAmbient(colorSensor);
		if(luz > LIGHT_FOUND){
			stopAllTasks();
		}
	}
}
