#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Ambient)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

///// VARIABLES GLOBALES
const int MAX_DISTANCE = 50;
const int FOLLOW_DISTANCE = 30;

const int DEFAULT_SPEED = 60;

const int TURNING_ANGLE = 145;
const int CORNING_ANGLE = 90;

const int LIGHT_FOUND = 50;
const int LIGHT_DETECTED = 10;

TSemaphore sem12, sem23, sem34;

task escape() {
	while(true) {
		int currentDistance = getUSDistance(sonarSensor);

		if(getTouchValue(touchSensor) == 1 || currentDistance < 5) {

			semaphoreLock(sem12);
			if(bDoesTaskOwnSemaphore(sem12)) {
				setMotorSpeed(leftMotor, -DEFAULT_SPEED);
				setMotorSpeed(rightMotor, -DEFAULT_SPEED);
				sleep(1000);
				resetGyro(gyroSensor);
				repeatUntil(getGyroDegrees(gyroSensor) >= CORNING_ANGLE) {
					setMotorSpeed(leftMotor, DEFAULT_SPEED);
					setMotorSpeed(rightMotor, -DEFAULT_SPEED);
				}
				resetGyro(gyroSensor);

				semaphoreUnlock(sem12);
			}
		}
	}
}

task light(){
	int luz;

	while(true){
		luz = getColorAmbient(colorSensor);

		if(luz != 0)
			writeDebugStreamLine("Luz = %d", luz);

		semaphoreLock(sem12);
		if (bDoesTaskOwnSemaphore(sem12)) {

			if(bDoesTaskOwnSemaphore(sem23)) {
				semaphoreUnlock(sem23);
			}

			if(luz >= LIGHT_DETECTED){
				semaphoreLock(sem23);
				setMotorSpeed(leftMotor, 30);
				setMotorSpeed(rightMotor, 0);

				while (luz <= getColorAmbient(colorSensor)) {
					luz = getColorAmbient(colorSensor);
				}
				setMotorSpeed(leftMotor, 0);
				setMotorSpeed(rightMotor, 30);

				while (luz <= getColorAmbient(colorSensor)) {
					luz = getColorAmbient(colorSensor);
				}
				semaphoreUnlock(sem23);
			}
			semaphoreUnlock(sem12);

		} else {
			if(!bDoesTaskOwnSemaphore(sem23)) {
				semaphoreLock(sem23);
			}
		}
	}
}

task follow_wall(){
	bool right_wall = false;

	while(true){
		int currentDistance = getUSDistance(sonarSensor);

		semaphoreLock(sem23);
		if(bDoesTaskOwnSemaphore(sem23)) {

			if(bDoesTaskOwnSemaphore(sem34)) {
				semaphoreUnlock(sem34);
			}

			if(currentDistance < FOLLOW_DISTANCE) {
				semaphoreLock(sem34);
					right_wall = true;
					resetGyro(gyroSensor);
					repeatUntil(getGyroDegrees(gyroSensor) >= TURNING_ANGLE) {
						setMotorSpeed(leftMotor, DEFAULT_SPEED);
						setMotorSpeed(rightMotor, -DEFAULT_SPEED);
					}
					resetGyro(S2);
				semaphoreUnlock(sem34);
			}

			if(right_wall && currentDistance > FOLLOW_DISTANCE) {
				semaphoreLock(sem34);
					resetGyro(S2);
					repeatUntil(getGyroDegrees(S2) <= -5) {
						setMotorSpeed(leftMotor, DEFAULT_SPEED - 20);
						setMotorSpeed(rightMotor, DEFAULT_SPEED + 20);
					}
					resetGyro(S2);
				semaphoreUnlock(sem34);
			}
			semaphoreUnlock(sem23);
		}	else {
			if(!bDoesTaskOwnSemaphore(sem34)) {
				semaphoreLock(sem34);
			}
		}
	}
}

task go_to_wall() {
	while(true) {
		int currentDistance = getUSDistance(sonarSensor);

		semaphoreLock(sem34);
		if(bDoesTaskOwnSemaphore(sem34)) {
			if (currentDistance > MAX_DISTANCE) {
				setMotorSpeed(leftMotor, DEFAULT_SPEED);
				setMotorSpeed(rightMotor, DEFAULT_SPEED);
			}	else {
				setMotorSpeed(leftMotor, currentDistance + 20);
				setMotorSpeed(rightMotor, currentDistance + 20);
			}
			semaphoreUnlock(sem34);
		}
	}
}

task main() {
	clearDebugStream();
	int luz;

	sleep(1000);

	luz = getColorAmbient(colorSensor);

	semaphoreInitialize(sem12);
	semaphoreInitialize(sem23);
	semaphoreInitialize(sem34);

	startTask(go_to_wall);
	startTask(follow_wall);
	startTask(light);
	startTask(escape);

	while(true){
		luz = getColorAmbient(colorSensor);
		if(luz > LIGHT_FOUND){
			stopAllTasks();
		}
	}
}
